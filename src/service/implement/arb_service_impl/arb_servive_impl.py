from typing import Dict

from src.model.alpha_metadata import AlphaMetadata, Params
from src.service.interface.arb_service.arb_service import ARBService
from src.service.interface.arb_supporter.confirmation_agent import ConfirmationAgent
from src.service.interface.arb_supporter.ner_agent import NerAgent
from src.service.interface.arb_supporter.function_calling_agent import FunctionCallingAgent
from src.service.interface.arb_supporter.normal_conversation_agent import NormalConversationAgent
from src.service.interface.arb_service.arb_db_service import ARBDBService
from src.utils.utils import format_entities_for_prompt
from src.utils.constants import FUNCTION_MAPPING_NAME

class ARBServiceImpl(ARBService):
    """
    Implementation of ARBService for the Predator chatbot system.
    This class manages multiple AI agents and their interactions for the Predator chatbot.
    """

    def __init__(
        self,
        casual_conversation_agent: NormalConversationAgent,
        confirmation_agent: ConfirmationAgent,
        ner_agent: NerAgent,
        function_calling_agent: FunctionCallingAgent,
        database: ARBDBService
    ) -> None:
        """
        Initialize the PredatorChatbot with required agents and configuration.

        Args:
            llm: Language model interface
            confirmation_agent: Agent for confirming user intents
            task_detection_agent: Agent for detecting tasks from user queries
            ner_agent: Agent for named entity recognition
            ner_verification_agent: Agent for verifying extracted entities
            history_context_folder: Path to store conversation history
            predator_chatbot_config: Configuration for the predator chatbot
        """
        # Initialize the agents
        self.casual_conversation_agent = casual_conversation_agent
        self.confirmation_agent = confirmation_agent
        self.ner_agent = ner_agent
        self.database = database
        self.function_calling_agent = function_calling_agent
        
        
    @staticmethod
    def __update_entities(previous_params: Dict[str, str], current_params: Dict[str, str]) -> Dict[str, str]:
        """
        Update the params from the from_params to the to_params
        Args:
            previous_params: The previous params
            current_params: The current params
        Returns:
            The updated params
        """
        if not previous_params:
            return current_params
        
        del current_params['date_range']
        updated_params = current_params.copy()
        
        if current_params['from_date'] != 'N/A':
            updated_params['from_date'] = current_params['from_date']
            
        if current_params['to_date'] != 'N/A':
            updated_params['to_date'] = current_params['to_date']
        
        for key, value in updated_params.items():
            if value == "N/A" or value == 'All':
                updated_params[key] = previous_params[key]
        return updated_params

    def chat(self, user_id: str, message: str) -> AlphaMetadata:
        """
        Process a message through the multi-agent system.

        Args:
            user_id: The user ID to process
            message: The input message to process

        Returns:
            str: The response generated by the agent system
        """
        
        # Initialize the flags
        is_new_session = False
        is_action = False
        is_normal_conversation = False
        
        # Extract entities from the message
        entities = self.ner_agent.extract_entities(message)
        
        # Get confirmation for the detected tasks and entities
        is_confirmed = self.confirmation_agent.get_decision(message)

        # Get the function calling
        function_called = self.function_calling_agent.call_function(message)
        
        # Convert endpoint to None if it is N/A
        if function_called == "N/A":
            function_called = None
        print('ğŸ¤– function_called: ', function_called)

        
        # Get the latest function
        previous_function = None
        previous_params = {}
        if self.database.get(user_id):
            user_database = self.database.get(user_id)
            previous_function = user_database[-1]['endpoint']
            previous_params = user_database[-1]['params']
        
        # Update the params
        update_entities = self.__update_entities(previous_params, entities)


        # Case 1: is_action            
        if is_confirmed:
            is_action = True
        print('ğŸ¤– is_action: ', is_action)
        # Case 2: is_new_session
        
        # Save the function called
        if function_called is None and previous_function is not None:
            function_called = previous_function
        print('ğŸ¤– previous_function: ', previous_function)
        print('ğŸ¤– function_called updated: ', function_called)
        function_name = FUNCTION_MAPPING_NAME[function_called]
        
        # Define the normal conversation
        if entities['from_date'] == 'N/A' and entities['to_date'] == 'N/A' and entities['product'] == 'All' and entities['product_detail'] == 'All' and entities['level'] == 'All' and entities['user'] == 'N/A' or function_called is None:
            is_normal_conversation = True
        print('ğŸ¤– is_normal_conversation: ', is_normal_conversation)
        
        # Case update function when the query is the greeting conversation
        if previous_function != function_called and previous_function is not None:
            is_new_session = True
            db_update_status = self.database.update(
                user_id=user_id, 
                metadata=[]
            )
            print('ğŸ¤– db_update_status: ', db_update_status)
        
        if not is_new_session:
            entities = update_entities
            
        # Generate response based on tasks, entities and confirmation
        if is_action:
        
            if entities['from_date'] == 'N/A':
                response = """
âš ï¸ NOTE THAT: 
    ğŸ“… From Date: REQUIRED
    ğŸ“… To Date: REQUIRED
    ğŸ¢ Product: Default is All
    ğŸ“‹ Product Detail: Default is All
    ğŸ® Level: Default is All
    ğŸ‘¤ User: Default is N/A
âŒ Please specify the date range for your request to proceed with generating the report.
                """
            elif function_called is None:
                response = f"""
âš ï¸ NOTE THAT: You should not confirm the information if you have not specified the function to proceed with generating the report.
âŒ Could not find the Function/Report. Please specify the function to proceed with generating the report.
                """
            else:
                response = f"""
ğŸ² Here is the summary of {function_name}:
    ğŸ‘¤ Username: {entities['user']}
    ğŸ¢ Product: {entities['product']}
    ğŸ“‹ Product Detail: {entities['product_detail']}
    ğŸ® Level: {entities['level']}
    ğŸ“… Date Range: {entities['from_date']} - {entities['to_date']}

âœ… Your request has been confirmed, please wait for a moment to get the report.
                """
                
        else:
            if is_normal_conversation:
                response = self.casual_conversation_agent.chat(message)
            else:
                response = f"""
ğŸ² Here is the summary of {function_name}:
    ğŸ‘¤ Username: {entities['user']}
    ğŸ¢ Product: {entities['product']}
    ğŸ“‹ Product Detail: {entities['product_detail']}
    ğŸ® Level: {entities['level']}
    ğŸ“… Date Range: {entities['from_date']} - {entities['to_date']}
    
âš ï¸ Would you like to confirm this information and proceed with the report generation?
                """
                
        print(f'ğŸ•µï¸ Request: {message}\n')
        print(f'ğŸ¤– Response: {response}\n') 
            
        print('ğŸ¤– current_params: \n', format_entities_for_prompt(entities))
        print('ğŸ¤– previous_params: \n', format_entities_for_prompt(previous_params))
            
        print("ğŸ©» is_new_session: ", is_new_session)
        print("ğŸ©» is_confirmed: ", is_confirmed)
        # Create params
        params = Params(
            from_date=entities['from_date'],
            to_date=entities['to_date'],
            product=entities['product'],
            product_detail=entities['product_detail'],
            level=entities['level'],
            user=entities['user']
        )
        
        # Update the metadata
        alpha_metadata = AlphaMetadata(
            user_id=user_id,
            is_new_session=is_new_session,
            is_action=is_action,
            endpoint=function_called,
            params=params,
            response=response
        )
            
        
        print("ğŸ‘» Params insert into database: \n")
        print(format_entities_for_prompt(alpha_metadata.to_dict()))
        
        # Insert the metadata into the database
        metadata_chain = self.database.get(user_id)
        if metadata_chain:
            metadata_chain.append(alpha_metadata.to_dict())
            self.database.insert(
                user_id=user_id,
                metadata=metadata_chain
            )
        else:
            self.database.insert(
                user_id=user_id,
                metadata=[alpha_metadata.to_dict()]
            )
            
        # Convert field user to None if it is N/A
        if alpha_metadata.params.user == "N/A":
            alpha_metadata.params.user = None
        
        # Convert params to None if from_date or function_called is N/A
        if not is_action:
            alpha_metadata.params = None
            alpha_metadata.endpoint = None
        
        if is_action and alpha_metadata.params.from_date == 'N/A':
            alpha_metadata.params = None
            alpha_metadata.endpoint = None
            
        print("ğŸ‘» Params show for user: \n")
        print(format_entities_for_prompt(alpha_metadata.to_dict()))
        
        return alpha_metadata
